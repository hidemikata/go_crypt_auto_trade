package trade_jadge_algo

import (
	"btcanallive_refact/app/model"
	"btcanallive_refact/app/trade_def"
	"fmt"
	"time"
)

type LongSma struct {
	sma_0 float64 //latest
	sma_1 float64
	sma_2 float64
	sma_3 float64
}

type ShortSma struct {
	sma_0 float64 //latest
	sma_1 float64
	sma_2 float64
}

type Sma struct {
	num_of_long  int
	num_of_short int
	Long         LongSma
	Short        ShortSma
}

var short_sma int
var long_sma int
var long_sma_margine int //解析は+２本必要
var now_date_margine int //現在時刻を省く

func init() {
	short_sma = 5
	long_sma = 25
	long_sma_margine = 3 //解析は+２本必要
	now_date_margine = 1 //現在時刻を省く
}

func second_to_zero(t time.Time) string {
	min := fmt.Sprintf("%02d", t.Minute())
	h := fmt.Sprintf("%02d", t.Hour())
	d := fmt.Sprintf("%02d", t.Day())
	m := fmt.Sprintf("%02d", int(t.Month()))
	y := fmt.Sprintf("%02d", t.Year())
	return y + "-" + m + "-" + d + " " + h + ":" + min + ":00"
}

func NewSmaAlgorithm() *Sma {
	return &Sma{
		num_of_long:  long_sma,
		num_of_short: short_sma,
	}
}
func (sma_obj *Sma) Analisis() {
	now := time.Now()
	margine_duration := time.Duration(now_date_margine)
	now_before_1min := now.Add(-(time.Minute * margine_duration))
	long_sma_duration := time.Duration(long_sma + long_sma_margine + now_date_margine)
	now_before_long_sma := now.Add(-(time.Minute * long_sma_duration))
	latest_str := second_to_zero(now_before_1min)
	past_str := second_to_zero(now_before_long_sma)

	records := model.GetCandleBetweenDate(past_str, latest_str)

	l := LongSma{
		sma_0: calc_sma(records[:], long_sma),
		sma_1: calc_sma(records[:len(records)-1], long_sma),
		sma_2: calc_sma(records[:len(records)-2], long_sma),
		sma_3: calc_sma(records[:len(records)-3], long_sma),
	}
	s := ShortSma{
		sma_0: calc_sma(records[:], short_sma),
		sma_1: calc_sma(records[:len(records)-1], short_sma),
		sma_2: calc_sma(records[:len(records)-2], short_sma),
	}
	sma_obj.Long = l
	sma_obj.Short = s
}

func calc_sma(records []trade_def.BtcJpy, duration int) float64 {
	if len(records) < duration {
		panic("")
	}
	total := 0.0
	start_i := len(records) - duration
	record_latest := records[start_i:]
	for i := range record_latest {
		total += record_latest[i].Close
	}
	return total / float64(len(record_latest))
}

func (sma_obj *Sma) IsDbCollectedData() bool {
	num_of_collect := long_sma + long_sma_margine + now_date_margine
	num_of_duration := time.Duration(num_of_collect)
	now := time.Now()

	if now.Second() > 50 {
		//50秒から５９秒の間は待つ
		sleep_times := 0
		for {
			//tikcerのタイムで足確定判断して、PCのタイムで解析スタートしようとしているので時間がずれる
			fmt.Println(now.Second(), "is_db_collected_data time is not 00 sec sleep0.5...")
			time.Sleep(500 * time.Millisecond) //now時間がX分59秒になることがあるので0.5秒待つ
			sleep_times++
			now = time.Now()
			if now.Second() == 0 {
				break
			}
		}
	} else if now.Second() > 10 {
		//10秒以上差が出てたら落とす
		fmt.Println(now)
		panic("")
	}

	before_date := now.Add(-(time.Minute * num_of_duration))
	now_str := second_to_zero(now)
	before_date_str := second_to_zero(before_date)

	count := model.GetNumberOfCandleBetweenDate(before_date_str, now_str)

	return count-1 == num_of_collect //00秒〜00秒なので１個余分なので引く
}

func (sma_obj *Sma) IsTradeOrder() bool {
	if sma_obj.Short.sma_2 < sma_obj.Long.sma_2 &&
		sma_obj.Short.sma_1 < sma_obj.Long.sma_1 &&
		sma_obj.Short.sma_0 > sma_obj.Long.sma_0 &&
		sma_obj.Short.sma_2 < sma_obj.Short.sma_1 &&
		sma_obj.Short.sma_1 < sma_obj.Short.sma_0 &&
		sma_obj.Long.sma_3 < sma_obj.Long.sma_2 &&
		sma_obj.Long.sma_2 < sma_obj.Long.sma_1 &&
		sma_obj.Long.sma_1 < sma_obj.Long.sma_0 {
		return true
	}
	return false
}

func (sma_obj *Sma) IsTradeFix() bool {
	return sma_obj.Short.sma_0 < sma_obj.Long.sma_0
}
